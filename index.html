<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retos de Simulaci√≥n</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The SPA uses a two-level navigation structure. The main view is a grid of interactive cards, each representing one of the 10 challenges. This provides a quick, scannable overview. Clicking a card transitions the user to a dedicated detail view for that specific challenge, hiding the main grid. This detail view is organized with clear sections for "Contexto", "Par√°metros", and "Gu√≠a de Soluci√≥n", making the dense information digestible. An interactive chart is included in the "Par√°metros" section to visually compare key data points. A prominent "back" button allows easy return to the main challenge grid. This structure was chosen over a simple long-scroll page because it follows the "overview first, then details-on-demand" principle, preventing user overload and creating a more focused, app-like experience for exploring the educational content. -->
    <!-- Visualization & Content Choices: For each challenge, key quantitative data is presented in two ways: a structured HTML table for precise lookups and a dynamic bar chart (using Chart.js/Canvas) for quick visual comparison. Goal: Compare key operational parameters. Viz Method: Interactive Bar Chart. Interaction: Tooltips on hover provide exact values. Justification: Visualizing parameters like failure rates vs. repair times (Reto 2) or different operational costs (Reto 9) allows users to grasp the core tensions and trade-offs of the simulation problem much faster than by reading a table alone. Textual content (Contexto, Gu√≠a) is presented in clean, readable blocks. Process flows mentioned in the guides are simplified into structured HTML/CSS diagrams (e.g., Reto 7), adhering to the no-SVG/Mermaid constraint while still conveying the cyclical nature of the processes. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .flow-diagram-step {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #f9fafb; /* bg-gray-50 */
            min-height: 60px;
            flex-grow: 1;
        }
        .flow-diagram-arrow {
            font-size: 1.5rem; /* text-2xl */
            color: #6b7280; /* text-gray-500 */
            margin: 0 0.5rem; /* mx-2 */
        }
    </style>
</head>
<body class="bg-stone-50 text-stone-800">

    <div id="app" class="container mx-auto px-4 py-8 md:py-12">

        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-teal-800">Retos de Simulaci√≥n</h1>
            <p class="mt-3 text-lg text-stone-700">¬°Bienvenido! Explora estos 10 desaf√≠os de ingenier√≠a dise√±ados para fortalecer tus habilidades en modelado y simulaci√≥n.</p>
            <p class="mt-1 text-md text-stone-600">Estos retos est√°n orientados principalmente para AnyLogic, pero tambi√©n pueden adaptarse para FlexSim u otros software de simulaci√≥n.</p>
        </header>

        <main id="challenge-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        </main>

        <section id="challenge-detail" class="hidden">
            <button id="back-button" class="mb-6 inline-flex items-center px-4 py-2 bg-teal-600 text-white font-semibold rounded-lg hover:bg-teal-700 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                Volver a los Retos
            </button>
            <div id="detail-content" class="bg-white p-6 md:p-8 rounded-xl shadow-lg">
                <h2 id="detail-title" class="text-2xl md:text-3xl font-bold text-teal-800 mb-6"></h2>
                
                <div class="space-y-8">
                    <div>
                        <h3 class="text-xl font-semibold border-b-2 border-teal-200 pb-2 mb-4">Contexto del Desaf√≠o</h3>
                        <p id="detail-context" class="text-stone-700 leading-relaxed"></p>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold border-b-2 border-teal-200 pb-2 mb-4">Par√°metros y Datos Clave</h3>
                         <p class="text-stone-600 mb-4">La siguiente tabla resume los datos num√©ricos para la simulaci√≥n. La gr√°fica interactiva a continuaci√≥n permite comparar visualmente algunos de los par√°metros m√°s importantes para entender r√°pidamente las magnitudes y relaciones en el sistema.</p>
                        <div class="overflow-x-auto mb-6">
                            <table id="detail-data-table" class="min-w-full bg-white border border-gray-200 rounded-lg">
                            </table>
                        </div>
                        <div class="chart-container">
                            <canvas id="detail-chart"></canvas>
                        </div>
                    </div>
                    
                    <div id="detail-diagram-container" class="hidden">
                         <h3 class="text-xl font-semibold border-b-2 border-teal-200 pb-2 mb-4">Diagrama del Proceso</h3>
                         <p class="text-stone-600 mb-4">Este es un diagrama simplificado que representa el flujo c√≠clico o secuencial del proceso descrito en el reto.</p>
                         <div id="detail-diagram" class="flex flex-wrap items-center justify-center p-4 bg-gray-50 rounded-lg"></div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold border-b-2 border-teal-200 pb-2 mb-4">Gu√≠a de Soluci√≥n</h3>
                        <div id="detail-guide" class="prose max-w-none text-stone-700"></div>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        const challengesData = [
            {
                id: 1,
                title: "Reto 1: Optimizaci√≥n de Taquillas",
                icon: "üéüÔ∏è",
                description: "Determinar el n√∫mero √≥ptimo de taquillas en un evento para minimizar esperas y costos.",
                context: "Se simular√° la operaci√≥n de las taquillas de un estadio o sala de conciertos durante las horas pico previas a un evento. El objetivo principal es determinar el n√∫mero √≥ptimo de taquillas que deben permanecer abiertas para, por un lado, minimizar el tiempo de espera de los clientes y, por otro, controlar los costos operativos, todo ello manteniendo un nivel de servicio que se considere aceptable. Se debe considerar el fen√≥meno de 'balking', donde los clientes deciden no unirse a la cola si la perciben como demasiado larga.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades"],
                    rows: [
                        ["Tasa de llegada (pico)", "Poisson (media = 100)", "grupos/hora"],
                        ["Tama√±o del grupo", "Discreta (1: 60%, 2: 30%, 3: 10%)", "personas/grupo"],
                        ["Tiempo de servicio", "Triangular (0.5, 1, 2)", "minutos/persona"],
                        ["N¬∫ inicial taquillas", "3 (par√°metro a variar)", "taquillas"],
                        ["Umbral de 'balking'", "10", "personas"],
                        ["Costo operativo", "20", "unidades monetarias/hora"],
                        ["Costo de espera", "0.1", "unidades monetarias/min/persona"]
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Iniciar un nuevo modelo en AnyLogic (unidades: minutos).</li>
                        <li>Usar PML: <code>Source</code> para llegadas, <code>Queue</code> para la cola (con capacidad finita para 'balking'), y <code>Service</code> con un <code>ResourcePool</code> para las taquillas.</li>
                        <li>Definir un agente "GrupoClientes" con un par√°metro para el tama√±o del grupo.</li>
                        <li>Hacer que el tiempo de servicio sea din√°mico, dependiendo del tama√±o del grupo.</li>
                        <li>Implementar la l√≥gica de 'balking': si <code>queue.size()</code> excede el umbral, desviar al agente a un <code>Sink</code> de clientes perdidos.</li>
                        <li>Parametrizar el n√∫mero de taquillas (capacidad del <code>ResourcePool</code>).</li>
                        <li>Recolectar estad√≠sticas: tiempo en sistema, tiempo en cola, clientes perdidos, utilizaci√≥n.</li>
                        <li>Ejecutar un experimento de variaci√≥n de par√°metros para encontrar el n√∫mero √≥ptimo de taquillas.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Tiempo M√≠n Servicio', 'Tiempo Moda Servicio', 'Tiempo M√°x Servicio'],
                        datasets: [{
                            label: 'Tiempo de Servicio por Persona (minutos)',
                            data: [0.5, 1, 2],
                            backgroundColor: ['#2dd4bf', '#0d9488', '#0f766e']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 2,
                title: "Reto 2: L√≠nea de Ensamblaje",
                icon: "‚öôÔ∏è",
                description: "Simular una l√≠nea de producci√≥n con fallos de m√°quina y b√∫feres para analizar su rendimiento.",
                context: "Este reto consiste en modelar una l√≠nea de producci√≥n simplificada compuesta por tres estaciones de trabajo (m√°quinas) en serie. Cada m√°quina tiene un tiempo de proceso y una tasa de fallo. Entre las m√°quinas, existen b√∫feres con capacidad limitada. Los objetivos son analizar el throughput, la utilizaci√≥n de las m√°quinas y el tama√±o de los b√∫feres, considerando el impacto de los fallos y el bloqueo por b√∫feres llenos.",
                dataTable: {
                    headers: ["Par√°metro", "M√°quina 1", "M√°quina 2", "M√°quina 3"],
                    rows: [
                       ["Tiempo de proceso (min)", "Triangular (5, 6, 7)", "Uniforme (4, 8)", "Exponencial (Œº=6)"],
                       ["Tiempo entre fallos (MTBF, min)", "Exponencial (Œº=120)", "Exponencial (Œº=180)", "Exponencial (Œº=150)"],
                       ["Tiempo de reparaci√≥n (MTTR, min)", "Uniforme (10, 20)", "Uniforme (15, 25)", "Triangular (8, 12, 18)"],
                       ["Capacidad B√∫fer Previo", "N/A", "5 unidades", "3 unidades"],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Usar PML: <code>Source</code> para la llegada de piezas.</li>
                        <li>Para cada m√°quina: usar <code>Queue</code> para el b√∫fer y <code>Service</code> para la m√°quina.</li>
                        <li>En cada bloque <code>Service</code>, configurar los fallos usando las distribuciones de MTBF y MTTR.</li>
                        <li>La l√≥gica de bloqueo es inherente en PML si las colas tienen capacidad finita.</li>
                        <li>Recolectar m√©tricas: throughput, utilizaci√≥n de m√°quinas, nivel de ocupaci√≥n de b√∫feres.</li>
                        <li>Experimentar variando la capacidad de los b√∫feres o los par√°metros de fiabilidad.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['M√°quina 1', 'M√°quina 2', 'M√°quina 3'],
                        datasets: [
                            {
                                label: 'Tiempo Promedio Entre Fallos (MTBF)',
                                data: [120, 180, 150],
                                backgroundColor: '#0d9488'
                            },
                             {
                                label: 'Tiempo Promedio de Reparaci√≥n (MTTR)',
                                data: [15, 20, 13], // MTTR averages: (10+20)/2=15, (15+25)/2=20, (8+12+18)/3=12.66 ~ 13
                                backgroundColor: '#f97316'
                            }
                        ]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Minutos' } } } }
                },
                isPlaceholder: false
            },
            {
                id: 3,
                title: "Reto 3: Gesti√≥n de Inventario",
                icon: "üì¶",
                description: "Simular una pol√≠tica de inventario (s, S) para un producto perecedero.",
                context: "Este reto se centra en la simulaci√≥n de un sistema de gesti√≥n de inventario para un √∫nico producto perecedero utilizando una pol√≠tica de revisi√≥n peri√≥dica (s, S). El nivel de inventario se revisa a intervalos fijos. Si cae por debajo de 's', se pide hasta 'S'. Se considera la demanda estoc√°stica, la vida √∫til del producto y costos de pedido, mantenimiento, falta de stock y desecho. El objetivo es encontrar 's' y 'S' √≥ptimos.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades", "Notas"],
                    rows: [
                        ["Demanda diaria", "Poisson (media = 20)", "unidades/d√≠a", ""],
                        ["Intervalo de revisi√≥n", "7", "d√≠as", ""],
                        ["Punto de reorden (s)", "30 (par√°metro a variar)", "unidades", "Rango: 10-50"],
                        ["Nivel objetivo (S)", "100 (par√°metro a variar)", "unidades", "Rango: 80-150"],
                        ["Costo de pedido", "50", "unidades monetarias/pedido", ""],
                        ["Costo de mantenimiento", "0.5", "unidades monetarias/unidad/d√≠a", "Inventario promedio"],
                        ["Costo de falta de stock", "10", "unidades monetarias/unidad", "Venta perdida"],
                        ["Vida √∫til del producto", "5", "d√≠as", "Desde recepci√≥n"],
                        ["Costo de desecho", "2", "unidades monetarias/unidad", ""],
                        ["Tiempo de entrega proveedor", "Uniforme (2, 4)", "d√≠as", ""],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Usar modelado basado en agentes o l√≥gica de eventos discretos. PML para llegadas de clientes.</li>
                        <li>Variables: <code>nivelInventarioActual</code>, <code>inventarioEnTransito</code>. Colecci√≥n para lotes (<code>cantidad</code>, <code>fechaCaducidad</code>).</li>
                        <li>Eventos: <code>LlegadaCliente</code> (satisface demanda FIFO por caducidad, registra falta de stock), <code>RevisionInventario</code> (pide si inv < s hasta S), <code>LlegadaPedido</code> (actualiza inventario y lotes), <code>FinDia</code> (actualiza vida √∫til, desecha caducados, calcula costo mantenimiento).</li>
                        <li>Acumular costos: pedidos, mantenimiento, falta de stock, desecho.</li>
                        <li>Usar optimizaci√≥n de AnyLogic para minimizar costo total variando 's' y 'S'.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Punto de Reorden (s) Inicial', 'Nivel Objetivo (S) Inicial'],
                        datasets: [{
                            label: 'Par√°metros de Pol√≠tica de Inventario (Unidades)',
                            data: [30, 100],
                            backgroundColor: ['#fbbf24', '#34d399']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 4,
                title: "Reto 4: Patio de Contenedores",
                icon: "üöÇ",
                description: "Simular operaciones en un patio ferroviario usando la Rail Library.",
                context: "Modelar un patio ferroviario donde los trenes llegan, se descomponen, los vagones se clasifican y se forman nuevos trenes. Se usar√° la Rail Library de AnyLogic para definir v√≠as, desv√≠os y movimiento de trenes/vagones. El objetivo es analizar capacidad, tiempos de procesamiento y utilizaci√≥n de v√≠as.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades", "Notas"],
                    rows: [
                        ["Tasa llegada trenes", "Exponencial (media = 120)", "minutos", ""],
                        ["N¬∫ vagones/tren", "Uniforme discreto (20, 30)", "vagones", ""],
                        ["Tipos de vagones", "3 tipos (A, B, C)", "-", "Asignaci√≥n aleatoria"],
                        ["V√≠as de clasificaci√≥n", "5 v√≠as", "v√≠as", "Longitud 600m c/u"],
                        ["Tiempo desacople vag√≥n", "Triangular (0.5, 1, 1.5)", "minutos", ""],
                        ["Tiempo acople vag√≥n", "Triangular (0.8, 1.2, 1.8)", "minutos", ""],
                        ["Criterio formaci√≥n tren A", "15 vagones tipo A", "vagones", ""],
                        ["Criterio formaci√≥n tren B", "10 vagones tipo B", "vagones", ""],
                        ["Criterio formaci√≥n tren C", "12 vagones tipo C", "vagones", ""],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Activar Rail Library. Dibujar topolog√≠a: v√≠a llegada, desv√≠os, 5 v√≠as clasificaci√≥n, v√≠a salida.</li>
                        <li>Agentes: <code>TrenEntrante</code> (con poblaci√≥n <code>Vagon</code>), <code>Vagon</code> (atributos: tipo, destino), <code>TrenSaliente</code>.</li>
                        <li>Usar <code>TrainSource</code> para llegadas.</li>
                        <li>Bloques Rail Library: <code>TrainMoveTo</code>, <code>TrainDecouple</code>, <code>TrainCouple</code>.</li>
                        <li>L√≥gica para locomotora de maniobras (recurso o agente).</li>
                        <li>L√≥gica de formaci√≥n de trenes de salida seg√∫n criterios.</li>
                        <li>M√©tricas: tiempo de tren en patio, utilizaci√≥n v√≠as, trenes procesados.</li>
                        <li>Desarrollar animaci√≥n 2D/3D para verificaci√≥n.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['M√≠n Vagones/Tren', 'M√°x Vagones/Tren', 'Vagones Tren A', 'Vagones Tren B', 'Vagones Tren C'],
                        datasets: [{
                            label: 'Configuraci√≥n de Vagones y Formaci√≥n de Trenes',
                            data: [20, 30, 15, 10, 12],
                            backgroundColor: ['#0ea5e9', '#0ea5e9', '#84cc16', '#84cc16', '#84cc16']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 5,
                title: "Reto 5: Call Center",
                icon: "üìû",
                description: "Dise√±ar y analizar un centro de atenci√≥n telef√≥nica con agentes multi-habilidad.",
                context: "Simular un call center que gestiona llamadas de diferentes tipos (ventas, soporte, facturaci√≥n) con agentes de habilidades espec√≠ficas. El objetivo es determinar la dotaci√≥n √≥ptima de personal para cumplir niveles de servicio (e.g., 80% llamadas atendidas en 20s) considerando la paciencia del cliente y abandonos.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades", "Notas"],
                    rows: [
                        ["Tasa llegada llamadas", "Poisson (media=200/hr, var√≠a)", "llamadas/hora", "Usar Schedule"],
                        ["Distribuci√≥n consultas", "Ventas: 40%, Soporte: 35%, Fact.: 25%", "%", ""],
                        ["Tiempo atenci√≥n Ventas", "LogNormal(5, 1.5)", "minutos", ""],
                        ["Tiempo atenci√≥n Soporte", "LogNormal(8, 2)", "minutos", ""],
                        ["Tiempo atenci√≥n Facturaci√≥n", "LogNormal(4, 1)", "minutos", ""],
                        ["N¬∫ agentes Ventas", "10 (par√°metro a variar)", "agentes", "Rango: 5-15"],
                        ["N¬∫ agentes Soporte", "8 (par√°metro a variar)", "agentes", "Rango: 4-12"],
                        ["N¬∫ agentes Facturaci√≥n", "6 (par√°metro a variar)", "agentes", "Rango: 3-10"],
                        ["Paciencia cliente (cola)", "Exponencial (media = 5)", "minutos", "Para abandono"],
                        ["Tiempo post-llamada", "Triangular (0.5, 0.8, 1.2)", "minutos", ""],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Usar PML. <code>Source</code> con <code>Schedule</code> para llegadas. Agente "Llamada" (atributos: tipoConsulta, horaLlegada).</li>
                        <li><code>SelectOutput</code> para dirigir llamadas por tipo.</li>
                        <li>Para cada tipo: <code>Queue</code>, <code>Service</code>. <code>ResourcePool</code> para cada grupo de agentes (Ventas, Soporte, Facturaci√≥n).</li>
                        <li>Implementar abandono (<code>Timeout</code> en <code>Queue</code> o evento en agente).</li>
                        <li>Modelar tiempo "wrap-up" (<code>Delay</code> adicional tras liberar agente).</li>
                        <li>M√©tricas: Nivel de servicio (e.g., % atendidas en <20s), tasa abandono, utilizaci√≥n agentes, tiempos espera, longitud colas.</li>
                        <li>Experimentar con dotaci√≥n de personal y/o enrutamiento basado en habilidades.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Agentes Ventas (Inicial)', 'Agentes Soporte (Inicial)', 'Agentes Facturaci√≥n (Inicial)'],
                        datasets: [{
                            label: 'Dotaci√≥n Inicial de Agentes por Habilidad',
                            data: [10, 8, 6],
                            backgroundColor: ['#14b8a6', '#f97316', '#6366f1']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 6,
                title: "Reto 6: Cl√≠nica de Urgencias",
                icon: "üè•",
                description: "Modelar el flujo de pacientes en una cl√≠nica para optimizar recursos.",
                context: "Simular el flujo de pacientes en una cl√≠nica de urgencias: registro, triaje (asignaci√≥n de urgencia), espera, consulta m√©dica (requiere m√©dico y sala), y alta. El objetivo es analizar tiempos de espera, duraci√≥n de estancia y utilizaci√≥n de recursos (personal, salas) para identificar cuellos de botella.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades", "Notas"],
                    rows: [
                        ["Tasa llegada pacientes", "Poisson (media=10/hr, var√≠a)", "pacientes/hr", "Usar Schedule"],
                        ["Niveles urgencia", "Urgente: 20%, Semi-U: 50%, No U: 30%", "%", "Asignar en triaje"],
                        ["Tiempo Registro", "Uniforme (2, 5)", "minutos", ""],
                        ["Tiempo Triaje", "Triangular (3, 5, 8)", "minutos", ""],
                        ["Tiempo Consulta (Urgente)", "LogNormal(30,10)", "minutos", ""],
                        ["Tiempo Consulta (Semi-U)", "LogNormal(20,5)", "minutos", ""],
                        ["Tiempo Consulta (No Urg.)", "LogNormal(15,5)", "minutos", ""],
                        ["Puestos registro", "2", "puestos", ""],
                        ["Enfermeras triaje", "3", "enfermeras", ""],
                        ["M√©dicos", "4 (par√°metro a variar)", "m√©dicos", "Rango: 2-6"],
                        ["Salas examen", "6", "salas", "Paciente necesita sala Y m√©dico"],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Usar PML. <code>Source</code> con <code>Schedule</code>. Agente "Paciente" (atributos: nivelUrgencia, horaLlegadaTotal).</li>
                        <li>Flujo: Registro (<code>Service</code> con RecursoPersonalRegistro), Triaje (<code>Service</code> con RecursoEnfermerasTriaje, asignar nivelUrgencia).</li>
                        <li>Cola para m√©dico (<code>Queue</code> con prioridades por nivelUrgencia).</li>
                        <li>Atenci√≥n m√©dica: <code>Seize</code> para M√©dico Y SalaExamen, <code>Delay</code> (tiempo consulta seg√∫n urgencia), <code>Release</code> de ambos recursos. <code>Sink</code> para salida.</li>
                        <li>Parametrizar n√∫mero de m√©dicos y/o salas.</li>
                        <li>M√©tricas: Tiempo estancia total, tiempos espera (triaje, m√©dico por urgencia), utilizaci√≥n personal y salas.</li>
                        <li>Considerar optimizaci√≥n para minimizar costos o cumplir objetivos de espera.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Puestos Registro', 'Enfermeras Triaje', 'M√©dicos (Inicial)', 'Salas Examen'],
                        datasets: [{
                            label: 'Recursos Iniciales de la Cl√≠nica',
                            data: [2, 3, 4, 6],
                            backgroundColor: ['#a855f7', '#ec4899', '#22c55e', '#f59e0b']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 7,
                title: "Reto 7: Movimiento de Tierras",
                icon: "üöö",
                description: "Simular una operaci√≥n de excavaci√≥n y transporte con camiones y cargadoras.",
                context: "Simular una operaci√≥n de excavaci√≥n y transporte de tierra. El sistema tiene un n√∫mero fijo de camiones y cargadoras. El ciclo de un cami√≥n es: hacer cola para ser cargado, viajar a un sitio de descarga, descargar y regresar vac√≠o. El objetivo es analizar la productividad (m¬≥ movidos por hora) y la utilizaci√≥n de los equipos. Este es un sistema de ciclo cerrado donde un n√∫mero fijo de camiones circula por el modelo.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades"],
                    rows: [
                        ["N√∫mero de camiones", "5 (par√°metro a variar)", "camiones"],
                        ["Capacidad de cami√≥n", "20", "m¬≥"],
                        ["N√∫mero de cargadoras", "2 (par√°metro a variar)", "cargadoras"],
                        ["Tiempo de carga", "Triangular (5, 8, 12)", "minutos"],
                        ["Tiempo de viaje (cargado)", "Uniforme (15, 25)", "minutos"],
                        ["Tiempo de descarga", "Triangular (3, 5, 7)", "minutos"],
                        ["Tiempo de viaje (vac√≠o)", "Uniforme (10, 20)", "minutos"],
                    ]
                },
                 diagram: {
                    type: 'flow',
                    steps: ['Cola para Carga', 'Carga', 'Viaje Cargado', 'Descarga', 'Viaje Vac√≠o']
                },
                guide: `
                     <ol class="list-decimal list-inside space-y-2">
                        <li>Crear el modelo con camiones como entidades.</li>
                        <li>Usar un <code>Source</code> para inyectar el n√∫mero inicial de camiones al inicio de la simulaci√≥n (e.g., <code>source.inject(NTrucks)</code>).</li>
                        <li>Dise√±ar el ciclo del cami√≥n en PML: <code>Queue</code> -> <code>Seize</code> (cargadora) -> <code>Delay</code> (carga) -> <code>Release</code> (cargadora) -> <code>Delay</code> (viaje cargado) -> <code>Delay</code> (descarga) -> <code>Delay</code> (viaje vac√≠o).</li>
                        <li>Conectar la salida del √∫ltimo <code>Delay</code> a la entrada de la <code>Queue</code> para cerrar el ciclo.</li>
                        <li>Definir un <code>ResourcePool</code> para las cargadoras.</li>
                        <li>Parametrizar el n√∫mero de camiones y cargadoras.</li>
                        <li>Recolectar m√©tricas: tierra total movida, utilizaci√≥n de camiones y cargadoras.</li>
                        <li>Realizar experimentos variando el n√∫mero de camiones y cargadoras.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Tiempo de Carga (Moda)', 'Viaje Cargado (Prom.)', 'Descarga (Moda)', 'Viaje Vac√≠o (Prom.)'],
                        datasets: [{
                            label: 'Tiempos del Ciclo del Cami√≥n (minutos)',
                            data: [8, 20, 5, 15], // Moda para triangular, Promedio para uniforme
                            backgroundColor: ['#f97316', '#0d9488', '#f59e0b', '#14b8a6']
                        }]
                    },
                    options: { maintainAspectRatio: false, indexAxis: 'y', scales: { x: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 8,
                title: "Reto 8: Red Log√≠stica",
                icon: "üåê",
                description: "Simular una red con f√°brica, centros de distribuci√≥n y clientes.",
                context: "Modelar una red log√≠stica con una f√°brica, dos CDs regionales y clientes. Productos se fabrican, env√≠an a CDs (seg√∫n demanda/inventario), y luego a clientes. Considerar tiempos de transporte y capacidades de veh√≠culos. Objetivos: analizar niveles de inventario, costos de transporte y tiempos de entrega.",
                dataTable: {
                    headers: ["Par√°metro", "F√°brica", "CD 1", "CD 2", "Unidades"],
                    rows: [
                        ["Tasa producci√≥n F√°brica", "100", "N/A", "N/A", "unidades/d√≠a"],
                        ["Almac√©n F√°brica", "1000", "N/A", "N/A", "unidades"],
                        ["Almac√©n CD", "N/A", "500", "400", "unidades"],
                        ["Pol√≠tica env√≠o F√°b. a CD1", "Inv < 100 -> hasta 400", "Inv < 100 -> hasta 400", "N/A", "-"],
                        ["Pol√≠tica env√≠o F√°b. a CD2", "Inv < 80 -> hasta 300", "N/A", "Inv < 80 -> hasta 300", "-"],
                        ["Demanda clientes CD1", "N/A", "Poisson (media=40)", "N/A", "unidades/d√≠a"],
                        ["Demanda clientes CD2", "N/A", "N/A", "Poisson (media=30)", "unidades/d√≠a"],
                        ["Tiempo transp. F√°b-CD1", "Uniforme (24, 36)", "N/A", "N/A", "horas"],
                        ["Tiempo transp. F√°b-CD2", "Uniforme (30, 48)", "N/A", "N/A", "horas"],
                        ["Capacidad cami√≥n F√°b-CD", "200", "N/A", "N/A", "unidades"],
                        ["Capacidad furgoneta CD-Cli", "N/A", "20", "15", "unidades"],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Combinar PML y modelado basado en agentes. Agentes: <code>Producto</code>, <code>Fabrica</code>, <code>CentroDistribucion</code>, <code>PedidoCliente</code>.</li>
                        <li><code>Fabrica</code>: produce <code>Producto</code> (<code>Source</code>, <code>Delay</code>) a inventario (<code>Queue</code>). L√≥gica de env√≠o a CDs.</li>
                        <li><code>CentroDistribucion</code> (poblaci√≥n): recibe de F√°brica, satisface demanda clientes, gestiona su inventario.</li>
                        <li><code>PedidoCliente</code>: generado por <code>Source</code> en zonas de CD, toma <code>Producto</code> del CD.</li>
                        <li>Transporte: <code>Delay</code> para tiempos. Considerar capacidad veh√≠culos (agrupar/dividir env√≠os).</li>
                        <li>Implementar pol√≠ticas de inventario (s,S) en F√°brica y CDs.</li>
                        <li>M√©tricas: Niveles inventario, costos transporte, tasa cumplimiento pedidos, tiempo entrega.</li>
                        <li>Experimentar con pol√≠ticas de inventario o capacidades de transporte.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Almac√©n F√°brica', 'Almac√©n CD1', 'Almac√©n CD2', 'Cami√≥n F√°b-CD', 'Furgoneta CD1-Cli', 'Furgoneta CD2-Cli'],
                        datasets: [{
                            label: 'Capacidades de Almacenamiento y Transporte (Unidades)',
                            data: [1000, 500, 400, 200, 20, 15],
                            backgroundColor: ['#0284c7', '#059669', '#059669', '#7c3aed', '#c026d3', '#c026d3']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            },
            {
                id: 9,
                title: "Reto 9: Pol√≠ticas de Mantenimiento",
                icon: "üîß",
                description: "Analizar y comparar pol√≠ticas de mantenimiento correctivo vs. preventivo para una flota.",
                context: "Simular una flota de equipos sujeta a aver√≠as. Comparar Mantenimiento Correctivo (reparar al fallar) vs. Mantenimiento Preventivo (revisiones programadas). Considerar equipos de reparaci√≥n limitados. Objetivo: evaluar costos totales (inactividad, reparaciones, preventivo) y disponibilidad de la flota. Ideal para modelado basado en agentes.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Distribuci√≥n", "Unidades/Notas"],
                    rows: [
                        ["N¬∫ de equipos en flota", "50", "equipos"],
                        ["Tiempo entre fallos (sin MP)", "Weibull (shape=2, scale=500)", "horas de uso"],
                        ["Tiempo reparaci√≥n (correctivo)", "Triangular (8, 12, 24)", "horas"],
                        ["Costo de inactividad", "100", "unidades monetarias/hora"],
                        ["Costo reparaci√≥n correctiva", "500 + 50/hora", "unidades monetarias"],
                        ["Intervalo de MP", "200", "horas de uso (Pol√≠tica 2)"],
                        ["Tiempo de MP", "Uniforme (4, 6)", "horas"],
                        ["Costo de MP", "200", "unidades monetarias/intervenci√≥n"],
                        ["Equipos/cuadrillas reparaci√≥n", "3", "equipos/cuadrillas"],
                    ]
                },
                guide: `
                     <ol class="list-decimal list-inside space-y-2">
                        <li>Modelado basado en agentes: <code>Equipo</code>, <code>EquipoReparacion</code>.</li>
                        <li>Agente <code>Equipo</code>: Statechart (Operando, Fallado, EnReparaci√≥n, EnMP). Variables: horasUso, tiempoHastaFallo. L√≥gica para programar fallos (Weibull) y MP. Solicita <code>EquipoReparacion</code>.</li>
                        <li><code>EquipoReparacion</code>: <code>ResourcePool</code> global o poblaci√≥n de agentes.</li>
                        <li><code>Main</code>: gestiona cola de solicitudes (priorizar correctivas).</li>
                        <li>Implementar dos escenarios o par√°metro para cambiar entre pol√≠ticas MC y MP.</li>
                        <li>M√©tricas: Costo total, disponibilidad flota, n¬∫ fallos, utilizaci√≥n equipos reparaci√≥n.</li>
                        <li>Comparar resultados de ambas pol√≠ticas.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['Costo Fijo Reparaci√≥n Correctiva', 'Costo Mantenimiento Preventivo'],
                        datasets: [{
                            label: 'Comparaci√≥n de Costos Fijos por Intervenci√≥n',
                            data: [500, 200], // Costo fijo de correctiva vs costo de MP
                            backgroundColor: ['#ef4444', '#22c55e']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Unidades Monetarias' } } } }
                },
                isPlaceholder: false
            },
            {
                id: 10,
                title: "Reto 10: Rutas de Reparto (GIS)",
                icon: "üó∫Ô∏è",
                description: "Optimizar rutas de veh√≠culos de reparto en un √°rea urbana usando mapas GIS.",
                context: "Planificar rutas para una flota de veh√≠culos que entregan paquetes a clientes en un √°rea urbana. Usar GIS de AnyLogic para ubicaciones (dep√≥sito, clientes) y c√°lculo de rutas. Objetivo: minimizar distancia/tiempo total, considerando capacidad de veh√≠culos. El VRP es complejo; la simulaci√≥n eval√∫a heur√≠sticas.",
                dataTable: {
                    headers: ["Par√°metro", "Valor / Especificaci√≥n", "Unidades", "Notas"],
                    rows: [
                        ["N¬∫ veh√≠culos reparto", "3", "veh√≠culos", ""],
                        ["Capacidad veh√≠culo", "20", "paquetes", ""],
                        ["Ubicaci√≥n dep√≥sito", "(Lat, Lon) o Direcci√≥n", "-", "Ej: NY"],
                        ["N¬∫ clientes", "30", "clientes", ""],
                        ["Ubicaciones clientes", "Lista (Lat, Lon) o Direcciones", "-", "Generar o usar datos"],
                        ["Pedido cliente", "Uniforme discreto (1, 3)", "paquetes", ""],
                        ["Tiempo servicio cliente", "Uniforme (5, 10)", "minutos", "Descarga"],
                        ["Velocidad veh√≠culos", "30 o de ruta GIS", "km/h", ""],
                        ["Horario operaci√≥n", "8:00 - 17:00", "-", ""],
                    ]
                },
                guide: `
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Integrar mapa GIS en <code>Main</code>. Agentes: <code>Vehiculo</code>, <code>Cliente</code>, <code>Deposito</code>.</li>
                        <li>Ubicar Dep√≥sito y Clientes (poblaci√≥n) en mapa GIS con coordenadas.</li>
                        <li>Agente <code>Vehiculo</code>: inicia en Dep√≥sito, lista de clientes/ruta. Usar <code>agent.moveTo(GISNode)</code> o <code>agent.moveTo(lat, lon)</code>.</li>
                        <li>L√≥gica de asignaci√≥n de clientes y secuenciaci√≥n (VRP):
                            <ul><li>Simple: heur√≠stica voraz (cliente m√°s cercano hasta llenar capacidad).</li>
                            <li>Avanzado: usar motor optimizaci√≥n AnyLogic para subproblemas o evaluar rutas externas.</li></ul>
                        </li>
                        <li>Simular reparto: veh√≠culos viajan, servicio en cliente (<code>Delay</code>), regresan a dep√≥sito.</li>
                        <li>M√©tricas: Distancia total, tiempo total rutas, paquetes entregados, utilizaci√≥n veh√≠culos.</li>
                        <li>Experimentar con n¬∫ veh√≠culos, capacidades, heur√≠sticas de enrutamiento.</li>
                    </ol>
                `,
                chartData: {
                    type: 'bar',
                    data: {
                        labels: ['N¬∫ Veh√≠culos', 'Capacidad/Veh√≠culo', 'N¬∫ Clientes'],
                        datasets: [{
                            label: 'Par√°metros Clave de la Flota y Demanda',
                            data: [3, 20, 30],
                            backgroundColor: ['#d946ef', '#fde047', '#0ea5e9']
                        }]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                },
                isPlaceholder: false
            }
        ];
        
        challengesData.sort((a,b) => a.id - b.id);

        const challengeGrid = document.getElementById('challenge-grid');
        const challengeDetail = document.getElementById('challenge-detail');
        const detailContent = document.getElementById('detail-content');
        const detailTitle = document.getElementById('detail-title');
        const detailContext = document.getElementById('detail-context');
        const detailDataTable = document.getElementById('detail-data-table');
        const detailGuide = document.getElementById('detail-guide');
        const detailDiagramContainer = document.getElementById('detail-diagram-container');
        const detailDiagram = document.getElementById('detail-diagram');
        const backButton = document.getElementById('back-button');

        let chartInstance = null;
        
        function createCard(challenge) {
            const card = document.createElement('div');
            card.className = `p-6 bg-white rounded-xl shadow-md hover:shadow-xl transition-shadow transform hover:-translate-y-1 cursor-pointer flex flex-col justify-between ${challenge.isPlaceholder ? 'opacity-60' : ''}`;
            card.dataset.challengeId = challenge.id;

            card.innerHTML = `
                <div>
                    <div class="flex items-center mb-4">
                        <span class="text-3xl mr-4">${challenge.icon}</span>
                        <h3 class="text-xl font-bold text-teal-800">${challenge.title}</h3>
                    </div>
                    <p class="text-stone-600">${challenge.description}</p>
                </div>
                ${challenge.isPlaceholder ? '<span class="mt-4 text-sm font-semibold text-orange-600">Pr√≥ximamente</span>' : '<span class="mt-4 text-sm font-semibold text-teal-600">Ver Detalles ‚Üí</span>'}
            `;

            if (!challenge.isPlaceholder) {
                card.addEventListener('click', () => showDetail(challenge.id));
            } else {
                 card.style.cursor = 'not-allowed';
            }
            return card;
        }

        function renderGrid() {
            challengeGrid.innerHTML = '';
            challengesData.forEach(challenge => {
                challengeGrid.appendChild(createCard(challenge));
            });
        }

        function showDetail(id) {
            const challenge = challengesData.find(c => c.id === id);
            if (!challenge || challenge.isPlaceholder) return;

            detailTitle.textContent = challenge.title;
            detailContext.textContent = challenge.context;
            
            detailDataTable.innerHTML = '';
            const thead = document.createElement('thead');
            thead.className = "bg-gray-100";
            let tr = document.createElement('tr');
            challenge.dataTable.headers.forEach(header => {
                const th = document.createElement('th');
                th.className = "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider";
                th.textContent = header;
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            detailDataTable.appendChild(thead);
            
            const tbody = document.createElement('tbody');
            tbody.className = "bg-white divide-y divide-gray-200";
            challenge.dataTable.rows.forEach(row => {
                tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.className = "px-6 py-4 whitespace-nowrap text-sm text-gray-700";
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            detailDataTable.appendChild(tbody);

            detailGuide.innerHTML = challenge.guide;

            if (challenge.diagram) {
                detailDiagram.innerHTML = '';
                challenge.diagram.steps.forEach((step, index) => {
                    const stepEl = document.createElement('div');
                    stepEl.className = 'flow-diagram-step';
                    stepEl.textContent = step;
                    detailDiagram.appendChild(stepEl);

                    if (index < challenge.diagram.steps.length - 1) {
                         const arrowEl = document.createElement('div');
                         arrowEl.className = 'flow-diagram-arrow';
                         arrowEl.innerHTML = '&#10230;'; // Right arrow unicode
                         detailDiagram.appendChild(arrowEl);
                    }
                });
                detailDiagramContainer.classList.remove('hidden');
            } else {
                detailDiagramContainer.classList.add('hidden');
            }

            if (chartInstance) {
                chartInstance.destroy();
            }
            const ctx = document.getElementById('detail-chart').getContext('2d');
            chartInstance = new Chart(ctx, challenge.chartData);

            challengeGrid.classList.add('hidden');
            challengeDetail.classList.remove('hidden');
            window.scrollTo(0, 0);
        }

        backButton.addEventListener('click', () => {
            challengeDetail.classList.add('hidden');
            challengeGrid.classList.remove('hidden');
        });

        renderGrid();
    });
    </script>
</body>
</html>
